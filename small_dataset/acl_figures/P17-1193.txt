<figure>1</figure>
<caption>Figure 1: A 1EC graph whose pagenumber is 3.</caption>
<mention10>"... graph may be greater than 2. Proof. The graph in Figure 1 gives an instance which is 1EC but the pagenumber ...  Column "1EC" indicates whether the restriction "1EC" is satisfied. e Figure 1: A 1EC graph whose pagenumber is 3. success in ...  }, otherwise P2 is violated as the case shown in Figure 1. In summary, the last condition . . + . ..."</mention10>
<mention20>"... is at most k. Theorem 1. The pagenumber of 1EC graph may be greater than 2. Proof. The graph in Figure 1 gives an instance which is 1EC but the pagenumber of which is 3. There is a cycle, namely a ...  to the  indicates whether the restriction "P2" is satisfied; Column "1EC" indicates whether the restriction "1EC" is satisfied. e Figure 1: A 1EC graph whose pagenumber is 3. success in designing dynamic programming algorithms for trees. Theorem 1 indicates that ...  edges in the series {e (sl k ,sr k ) }, otherwise P2 is violated as the case shown in Figure 1. In summary, the last condition . . + . + is satisfied and we have a C1 structure in ..."</mention20>
<mention50>"... pagenumber of G is the minimum number of pages required for a book embedding of G. For sake of concision, we say a graph is "pagenumber-k", meaning that the pagenumber is at most k. Theorem 1. The pagenumber of 1EC graph may be greater than 2. Proof. The graph in Figure 1 gives an instance which is 1EC but the pagenumber of which is 3. There is a cycle, namely a → c → e → b → d → a, consisting of odd number of edges. Pitler et al. (2013) proved that 1EC trees are a subclass of graphs whose pagenumber is at most 2. This property provides the foundation to the  indicates whether the restriction "P2" is satisfied; Column "1EC" indicates whether the restriction "1EC" is satisfied. e Figure 1: A 1EC graph whose pagenumber is 3. success in designing dynamic programming algorithms for trees. Theorem 1 indicates that when we consider more general graph, the case is more complicated. In this paper, we study graphs that are constrained to be both 1EC and P2. We call them 1EC/P2 ...  two edges: e (x,p 1 ) and e (x,p 2 ) that cross e (i,s 2 ) and e (sr n−1 ,j) respectively. There must be an odd number of edges in the series {e (sl k ,sr k ) }, otherwise P2 is violated as the case shown in Figure 1. In summary, the last condition . . + . + is satisfied and we have a C1 structure in this LR sub-problem. We illustrate the decomposition using the graphical representations shown in Figure 7. When a &lt; b, since a is the upper-plane endpoint farthest to the right, and ..."</mention50>
<lines3> Proof. The graph in Figure 1 gives an instance which is 1EC but the pagenumber of which is 3. There is a cycle, namely a → c → e → b → d → a, consisting of odd number of edges. ...  This property provides the foundation to the  indicates whether the restriction "P2" is satisfied; Column "1EC" indicates whether the restriction "1EC" is satisfied. e Figure 1: A 1EC graph whose pagenumber is 3. success in designing dynamic programming algorithms for trees. Theorem 1 indicates that when we consider more general graph, the case is more complicated. ...  Due to the existence of e (x,s 2 ) and e (x,sr n−1 ) , there must be two edges: e (x,p 1 ) and e (x,p 2 ) that cross e (i,s 2 ) and e (sr n−1 ,j) respectively. There must be an odd number of edges in the series {e (sl k ,sr k ) }, otherwise P2 is violated as the case shown in Figure 1. 1n summary, the last condition"</lines3>
<lines5> The pagenumber of 1EC graph may be greater than 2. Proof. The graph in Figure 1 gives an instance which is 1EC but the pagenumber of which is 3. There is a cycle, namely a → c → e → b → d → a, consisting of odd number of edges. Pitler et al (2013) proved that 1EC trees are a subclass of graphs whose pagenumber is at most 2. This property provides the foundation to the  indicates whether the restriction "P2" is satisfied; Column "1EC" indicates whether the restriction "1EC" is satisfied. e Figure 1: A 1EC graph whose pagenumber is 3. success in designing dynamic programming algorithms for trees. Theorem 1 indicates that when we consider more general graph, the case is more complicated. 1n this paper, we study graphs that are constrained to be both 1EC and P2. ...  Condition 7. Due to the existence of e (x,s 2 ) and e (x,sr n−1 ) , there must be two edges: e (x,p 1 ) and e (x,p 2 ) that cross e (i,s 2 ) and e (sr n−1 ,j) respectively. There must be an odd number of edges in the series {e (sl k ,sr k ) }, otherwise P2 is violated as the case shown in Figure 1. 1n summary, the last condition"</lines5>
<snippet3> Proof. The graph in Figure 1 gives an instance which is 1EC but the pagenumber of which is 3. There is a cycle, namely a → c → e → b → d → a, consisting of odd number of edges.</snippet3>
<snippet5> The pagenumber of 1EC graph may be greater than 2. Proof. The graph in Figure 1 gives an instance which is 1EC but the pagenumber of which is 3. There is a cycle, namely a → c → e → b → d → a, consisting of odd number of edges. Pitler et al (2013) proved that 1EC trees are a subclass of graphs whose pagenumber is at most 2. This property provides the foundation to the  indicates whether the restriction "P2" is satisfied; Column "1EC" indicates whether the restriction "1EC" is satisfied. e Figure 1: A 1EC graph whose pagenumber is 3. success in designing dynamic programming algorithms for trees. Theorem 1 indicates that when we consider more general graph, the case is more complicated. 1n this paper, we study graphs that are constrained to be both 1EC and P2.</snippet5>
<abstract>We study the Maximum Subgraph problem in deep dependency parsing. We consider two restrictions to deep dependency graphs: (a) 1-endpoint-crossing and (b) pagenumber-2. Our main contribution is an exact algorithm that obtains maximum subgraphs satisfying both restrictions simultaneously in time O(n 5). Moreover, ignoring one linguistically-rare structure descreases the complexity to O(n 4). We also extend our quartic-time algorithm into a practical parser with a discriminative dis-ambiguation model and evaluate its performance on four linguistic data sets used in semantic dependency parsing.</abstract>
<title>Parsing to 1-Endpoint-Crossing, Pagenumber-2 Graphs</title>
<introduction>Dependency parsing has long been studied as a central issue in developing syntactic or semantic analysis. Recently, some linguistic projects grounded on deep grammar formalisms, including CCG, LFG, and HPSG, draw attentions to rich syntactic and semantic dependency annotations that are not limited to trees (Hockenmaier and Steed- man, 2007;Ivanova et al., 2012). Parsing for these deep dependency representations can be viewed as the search for Maximum Subgraphs ( Kuhlmann and Jonsson, 2015). This is a natural extension of the Maximum Spanning Tree (MST) perspective (McDonald et al., 2005) for dependency tree parisng.One main challenge of the Maximum Subgraph perspective is to design tracTable algorithms for certain graph classes that have good empirical coverage for linguistic annotations. Unfortunately, no previously defined class simultaneously has high * The first two authors contribute equally.coverage and low-degree polynomial parsing algorithms. For example, noncrossing dependency graphs can be found in time O(n 3 ), but cover only 48.23% of sentences in CCGBank ( Kuhlmann and Jonsson, 2015).We study two well-motivated restrictions to deep dependency graphs: (a) 1-endpoint-crossing (1EC hereafter; Pitler et al., 2013) and (b) pagenumber is less than or equal to 2 (P2 hereafter; Kuhlmann and Jonsson, 2015). We will show that if the output dependency graphs are restricted to satisfy both restrictions, the Maximum Subgraph problem can be solved using dynamic programming in time O(n 5 ). Moreover, if we ignore one linguistically-rare sub-problem, we can reduce the time complexity to O(n 4 ). Though this new algorithm is a degenerated one, it has the same empirical coverage for various deep dependency annotations. We evaluate the coverage of our algorithms on four linguistic data sets: CCGBank, DeepBank, Enju HPSGBank and Prague Dependency TreeBank. They cover 95.68%, 97.67%, 97.28% and 97.53% of dependency graphs in the four corpora. The relatively satisfactory coverage makes it possible to parse with high accuracy.Based on the quartic-time algorithm, we implement a parser with a discriminative disambiguation model. Our new parser can be taken as a graph-based parser which is complementary to transition-based ( Henderson et al., 2013;Zhang et al., 2016) and factorization-based (Mar- tins and Almeida, 2014;Du et al., 2015a) systems. We evaluate our parser on four data sets: those used in Task 8 (Oepen et al., 2014, and the dependency graphs extracted from CCGbank (Hockenmaier and Steed- man, 2007). Evaluations indicate that our parser produces very accurate deep dependency analysis. It reaches state-of-the-art results on average produced by a transition-based system of Zhang et al. (2016) and factorization-based systems (Martins and Almeida, 2014;Du et al., 2015a).The implementation of our parser is available at http://www.icst.pku.edu.cn/ lcwm/grass.</introduction>
<file>P17-1193-Figure1-1.png</file>
<figure>2</figure>
<caption>Figure 2: Graphic representations of sub-problems.</caption>
<mention10>"... we allow at most one arc between two nodes, b Figure 2: Graphic representations of sub-problems. The graphical illustration of our ..."</mention10>
<mention20>"... it to currently the best solution of a sub-problem. If we allow at most one arc between two nodes, b Figure 2: Graphic representations of sub-problems. The graphical illustration of our algorithm uses undirected graphs 1 . In other words, we ..."</mention20>
<mention50>"... the arc weight associated with Then we define a function SELECT(i, j) according to the comparison of 0 and w[i, j] as well as (or a (j,i) ) and add it to currently the best solution of a sub-problem. If we allow at most one arc between two nodes, b Figure 2: Graphic representations of sub-problems. The graphical illustration of our algorithm uses undirected graphs 1 . In other words, we use e (i,j) to include the discussion about both a (i,j) and a (j,i) . We consider six sub-problems when we construct a maximum dependency graph on a given (closed) ..."</mention50>
<lines3> Assume the arc weight associated with Then we define a function SELECT(i, j) according to the comparison of 0 and w[i, j] as well as (or a (j,i) ) and add it to currently the best solution of a sub-problem. 1f we allow at most one arc between two nodes, b Figure 2: Graphic representations of sub-problems. The graphical illustration of our algorithm uses undirected graphs 1"</lines3>
<lines5> 1n particular, we figure out some edges, in each construction step, which can be created without violating either 1EC or P2 restriction. Assume the arc weight associated with Then we define a function SELECT(i, j) according to the comparison of 0 and w[i, j] as well as (or a (j,i) ) and add it to currently the best solution of a sub-problem. 1f we allow at most one arc between two nodes, b Figure 2: Graphic representations of sub-problems. The graphical illustration of our algorithm uses undirected graphs 1 . 1n other words, we use e (i,j) to include the discussion about both a (i,j) and a (j,i)"</lines5>
<snippet3> Assume the arc weight associated with Then we define a function SELECT(i, j) according to the comparison of 0 and w[i, j] as well as (or a (j,i) ) and add it to currently the best solution of a sub-problem. 1f we allow at most one arc between two nodes, b Figure 2: Graphic representations of sub-problems. The graphical illustration of our algorithm uses undirected graphs 1"</snippet3>
<snippet5> 1n particular, we figure out some edges, in each construction step, which can be created without violating either 1EC or P2 restriction. Assume the arc weight associated with Then we define a function SELECT(i, j) according to the comparison of 0 and w[i, j] as well as (or a (j,i) ) and add it to currently the best solution of a sub-problem. 1f we allow at most one arc between two nodes, b Figure 2: Graphic representations of sub-problems. The graphical illustration of our algorithm uses undirected graphs 1 . 1n other words, we use e (i,j) to include the discussion about both a (i,j) and a (j,i)"</snippet5>
<abstract>We study the Maximum Subgraph problem in deep dependency parsing. We consider two restrictions to deep dependency graphs: (a) 1-endpoint-crossing and (b) pagenumber-2. Our main contribution is an exact algorithm that obtains maximum subgraphs satisfying both restrictions simultaneously in time O(n 5). Moreover, ignoring one linguistically-rare structure descreases the complexity to O(n 4). We also extend our quartic-time algorithm into a practical parser with a discriminative dis-ambiguation model and evaluate its performance on four linguistic data sets used in semantic dependency parsing.</abstract>
<title>Parsing to 1-Endpoint-Crossing, Pagenumber-2 Graphs</title>
<introduction>Dependency parsing has long been studied as a central issue in developing syntactic or semantic analysis. Recently, some linguistic projects grounded on deep grammar formalisms, including CCG, LFG, and HPSG, draw attentions to rich syntactic and semantic dependency annotations that are not limited to trees (Hockenmaier and Steed- man, 2007;Ivanova et al., 2012). Parsing for these deep dependency representations can be viewed as the search for Maximum Subgraphs ( Kuhlmann and Jonsson, 2015). This is a natural extension of the Maximum Spanning Tree (MST) perspective (McDonald et al., 2005) for dependency tree parisng.One main challenge of the Maximum Subgraph perspective is to design tracTable algorithms for certain graph classes that have good empirical coverage for linguistic annotations. Unfortunately, no previously defined class simultaneously has high * The first two authors contribute equally.coverage and low-degree polynomial parsing algorithms. For example, noncrossing dependency graphs can be found in time O(n 3 ), but cover only 48.23% of sentences in CCGBank ( Kuhlmann and Jonsson, 2015).We study two well-motivated restrictions to deep dependency graphs: (a) 1-endpoint-crossing (1EC hereafter; Pitler et al., 2013) and (b) pagenumber is less than or equal to 2 (P2 hereafter; Kuhlmann and Jonsson, 2015). We will show that if the output dependency graphs are restricted to satisfy both restrictions, the Maximum Subgraph problem can be solved using dynamic programming in time O(n 5 ). Moreover, if we ignore one linguistically-rare sub-problem, we can reduce the time complexity to O(n 4 ). Though this new algorithm is a degenerated one, it has the same empirical coverage for various deep dependency annotations. We evaluate the coverage of our algorithms on four linguistic data sets: CCGBank, DeepBank, Enju HPSGBank and Prague Dependency TreeBank. They cover 95.68%, 97.67%, 97.28% and 97.53% of dependency graphs in the four corpora. The relatively satisfactory coverage makes it possible to parse with high accuracy.Based on the quartic-time algorithm, we implement a parser with a discriminative disambiguation model. Our new parser can be taken as a graph-based parser which is complementary to transition-based ( Henderson et al., 2013;Zhang et al., 2016) and factorization-based (Mar- tins and Almeida, 2014;Du et al., 2015a) systems. We evaluate our parser on four data sets: those used in Task 8 (Oepen et al., 2014, and the dependency graphs extracted from CCGbank (Hockenmaier and Steed- man, 2007). Evaluations indicate that our parser produces very accurate deep dependency analysis. It reaches state-of-the-art results on average produced by a transition-based system of Zhang et al. (2016) and factorization-based systems (Martins and Almeida, 2014;Du et al., 2015a).The implementation of our parser is available at http://www.icst.pku.edu.cn/ lcwm/grass.</introduction>
<file>P17-1193-Figure2-1.png</file>
<figure>7</figure>
<caption>Figure 7: Decomposition for C[x, i, a, b].</caption>
<mention10>"... We illustrate the decomposition using the graphical representations shown in Figure 7. When a &lt; b, since a is the upper-plane ..."</mention10>
<mention20>"... and we have a C1 structure in this LR sub-problem. We illustrate the decomposition using the graphical representations shown in Figure 7. When a &lt; b, since a is the upper-plane endpoint farthest to the right, and b is the lower-plane ..."</mention20>
<mention50>"... {e (sl k ,sr k ) }, otherwise P2 is violated as the case shown in Figure 1. In summary, the last condition . . + . + is satisfied and we have a C1 structure in this LR sub-problem. We illustrate the decomposition using the graphical representations shown in Figure 7. When a &lt; b, since a is the upper-plane endpoint farthest to the right, and b is the lower-plane counterpart, in this case a precedes b (i.e., a is to the left of b). When a &gt; b and n &gt; 2, the lower-plane endpoint b precedes a. In ..."</mention50>
<lines3> + is satisfied and we have a C1 structure in this LR sub-problem. We illustrate the decomposition using the graphical representations shown in Figure 7. When a &lt; b, since a is the upper-plane endpoint farthest to the right, and b is the lower-plane counterpart, in this case a precedes b (i.e., a is to the left of b)"</lines3>
<lines5> + . + is satisfied and we have a C1 structure in this LR sub-problem. We illustrate the decomposition using the graphical representations shown in Figure 7. When a &lt; b, since a is the upper-plane endpoint farthest to the right, and b is the lower-plane counterpart, in this case a precedes b (i.e., a is to the left of b). When a &gt; b and n &gt; 2, the lower-plane endpoint b precedes a"</lines5>
<snippet3> + is satisfied and we have a C1 structure in this LR sub-problem. We illustrate the decomposition using the graphical representations shown in Figure 7. When a &lt; b, since a is the upper-plane endpoint farthest to the right, and b is the lower-plane counterpart, in this case a precedes b (i.e., a is to the left of b)"</snippet3>
<snippet5> + . + is satisfied and we have a C1 structure in this LR sub-problem. We illustrate the decomposition using the graphical representations shown in Figure 7. When a &lt; b, since a is the upper-plane endpoint farthest to the right, and b is the lower-plane counterpart, in this case a precedes b (i.e., a is to the left of b). When a &gt; b and n &gt; 2, the lower-plane endpoint b precedes a"</snippet5>
<abstract>We study the Maximum Subgraph problem in deep dependency parsing. We consider two restrictions to deep dependency graphs: (a) 1-endpoint-crossing and (b) pagenumber-2. Our main contribution is an exact algorithm that obtains maximum subgraphs satisfying both restrictions simultaneously in time O(n 5). Moreover, ignoring one linguistically-rare structure descreases the complexity to O(n 4). We also extend our quartic-time algorithm into a practical parser with a discriminative dis-ambiguation model and evaluate its performance on four linguistic data sets used in semantic dependency parsing.</abstract>
<title>Parsing to 1-Endpoint-Crossing, Pagenumber-2 Graphs</title>
<introduction>Dependency parsing has long been studied as a central issue in developing syntactic or semantic analysis. Recently, some linguistic projects grounded on deep grammar formalisms, including CCG, LFG, and HPSG, draw attentions to rich syntactic and semantic dependency annotations that are not limited to trees (Hockenmaier and Steed- man, 2007;Ivanova et al., 2012). Parsing for these deep dependency representations can be viewed as the search for Maximum Subgraphs ( Kuhlmann and Jonsson, 2015). This is a natural extension of the Maximum Spanning Tree (MST) perspective (McDonald et al., 2005) for dependency tree parisng.One main challenge of the Maximum Subgraph perspective is to design tracTable algorithms for certain graph classes that have good empirical coverage for linguistic annotations. Unfortunately, no previously defined class simultaneously has high * The first two authors contribute equally.coverage and low-degree polynomial parsing algorithms. For example, noncrossing dependency graphs can be found in time O(n 3 ), but cover only 48.23% of sentences in CCGBank ( Kuhlmann and Jonsson, 2015).We study two well-motivated restrictions to deep dependency graphs: (a) 1-endpoint-crossing (1EC hereafter; Pitler et al., 2013) and (b) pagenumber is less than or equal to 2 (P2 hereafter; Kuhlmann and Jonsson, 2015). We will show that if the output dependency graphs are restricted to satisfy both restrictions, the Maximum Subgraph problem can be solved using dynamic programming in time O(n 5 ). Moreover, if we ignore one linguistically-rare sub-problem, we can reduce the time complexity to O(n 4 ). Though this new algorithm is a degenerated one, it has the same empirical coverage for various deep dependency annotations. We evaluate the coverage of our algorithms on four linguistic data sets: CCGBank, DeepBank, Enju HPSGBank and Prague Dependency TreeBank. They cover 95.68%, 97.67%, 97.28% and 97.53% of dependency graphs in the four corpora. The relatively satisfactory coverage makes it possible to parse with high accuracy.Based on the quartic-time algorithm, we implement a parser with a discriminative disambiguation model. Our new parser can be taken as a graph-based parser which is complementary to transition-based ( Henderson et al., 2013;Zhang et al., 2016) and factorization-based (Mar- tins and Almeida, 2014;Du et al., 2015a) systems. We evaluate our parser on four data sets: those used in Task 8 (Oepen et al., 2014, and the dependency graphs extracted from CCGbank (Hockenmaier and Steed- man, 2007). Evaluations indicate that our parser produces very accurate deep dependency analysis. It reaches state-of-the-art results on average produced by a transition-based system of Zhang et al. (2016) and factorization-based systems (Martins and Almeida, 2014;Du et al., 2015a).The implementation of our parser is available at http://www.icst.pku.edu.cn/ lcwm/grass.</introduction>
<file>P17-1193-Figure7-1.png</file>
<figure>8</figure>
<caption>Figure 8: A maximal 1EC/P2 graph and its two derivations. For brevity, we elide the edges created in each derivation step.</caption>
<mention10>"... by applying these rules, we never violate 1EC nor P2 Figure 8: A maximal 1EC/P2 graph and its two derivations. For ...  even a maximal 1EC/P2 graph, we may have different derivations. Figure 8 is an example. This is similar to syntactic analysis ..."</mention10>
<mention20>"... The decomposition rules are also construction rules. During constructing graphs by applying these rules, we never violate 1EC nor P2 Figure 8: A maximal 1EC/P2 graph and its two derivations. For brevity, we elide the edges created in each derivation step. ...  There is no local search. To generate the same graph, even a maximal 1EC/P2 graph, we may have different derivations. Figure 8 is an example. This is similar to syntactic analysis licensed by Combinatory Categorial Grammar (CCG;Steedman, 1996Steedman, , 2000). To ..."</mention20>
<mention50>"... the decomposition rules. The completeness is obvious because we can decompose any 1EC/P2 graph from an Int, use our rules to reduce it into smaller sub-problems, and repeat this procedure. The decomposition rules are also construction rules. During constructing graphs by applying these rules, we never violate 1EC nor P2 Figure 8: A maximal 1EC/P2 graph and its two derivations. For brevity, we elide the edges created in each derivation step. restrictions. So our algorithm is sound. There is an important difference between our algorithm and Eisner-style MST algorithms (Eis- ner, 1996b;McDonald and Pereira, 2006;Car- reras, 2007;Koo and Collins, 2010) for ...  more arc voilates the 1EC or P2 restrictions. For all other aforementioned algorithms, in a single construction step, it is clear whether to add a new arc, and which one. There is no local search. To generate the same graph, even a maximal 1EC/P2 graph, we may have different derivations. Figure 8 is an example. This is similar to syntactic analysis licensed by Combinatory Categorial Grammar (CCG;Steedman, 1996Steedman, , 2000). To derive one surface string, there usually exists multiple CCG derivations. A practice of CCG parsing is defining one particular derivation as the standard one, namely normal form (Eisner, 1996a). The ..."</mention50>
<lines3> The decomposition rules are also construction rules. During constructing graphs by applying these rules, we never violate 1EC nor P2 Figure 8: A maximal 1EC/P2 graph and its two derivations. For brevity, we elide the edges created in each derivation step. ...  To generate the same graph, even a maximal 1EC/P2 graph, we may have different derivations. Figure 8 is an example. This is similar to syntactic analysis licensed by Combinatory Categorial Grammar (CCG;Steedman, 1996Steedman, , 2000)"</lines3>
<lines5> The completeness is obvious because we can decompose any 1EC/P2 graph from an 1nt, use our rules to reduce it into smaller sub-problems, and repeat this procedure. The decomposition rules are also construction rules. During constructing graphs by applying these rules, we never violate 1EC nor P2 Figure 8: A maximal 1EC/P2 graph and its two derivations. For brevity, we elide the edges created in each derivation step. restrictions. ...  There is no local search. To generate the same graph, even a maximal 1EC/P2 graph, we may have different derivations. Figure 8 is an example. This is similar to syntactic analysis licensed by Combinatory Categorial Grammar (CCG;Steedman, 1996Steedman, , 2000). To derive one surface string, there usually exists multiple CCG derivations"</lines5>
<snippet3> The decomposition rules are also construction rules. During constructing graphs by applying these rules, we never violate 1EC nor P2 Figure 8: A maximal 1EC/P2 graph and its two derivations. For brevity, we elide the edges created in each derivation step.</snippet3>
<snippet5> The completeness is obvious because we can decompose any 1EC/P2 graph from an 1nt, use our rules to reduce it into smaller sub-problems, and repeat this procedure. The decomposition rules are also construction rules. During constructing graphs by applying these rules, we never violate 1EC nor P2 Figure 8: A maximal 1EC/P2 graph and its two derivations. For brevity, we elide the edges created in each derivation step. restrictions.</snippet5>
<abstract>We study the Maximum Subgraph problem in deep dependency parsing. We consider two restrictions to deep dependency graphs: (a) 1-endpoint-crossing and (b) pagenumber-2. Our main contribution is an exact algorithm that obtains maximum subgraphs satisfying both restrictions simultaneously in time O(n 5). Moreover, ignoring one linguistically-rare structure descreases the complexity to O(n 4). We also extend our quartic-time algorithm into a practical parser with a discriminative dis-ambiguation model and evaluate its performance on four linguistic data sets used in semantic dependency parsing.</abstract>
<title>Parsing to 1-Endpoint-Crossing, Pagenumber-2 Graphs</title>
<introduction>Dependency parsing has long been studied as a central issue in developing syntactic or semantic analysis. Recently, some linguistic projects grounded on deep grammar formalisms, including CCG, LFG, and HPSG, draw attentions to rich syntactic and semantic dependency annotations that are not limited to trees (Hockenmaier and Steed- man, 2007;Ivanova et al., 2012). Parsing for these deep dependency representations can be viewed as the search for Maximum Subgraphs ( Kuhlmann and Jonsson, 2015). This is a natural extension of the Maximum Spanning Tree (MST) perspective (McDonald et al., 2005) for dependency tree parisng.One main challenge of the Maximum Subgraph perspective is to design tracTable algorithms for certain graph classes that have good empirical coverage for linguistic annotations. Unfortunately, no previously defined class simultaneously has high * The first two authors contribute equally.coverage and low-degree polynomial parsing algorithms. For example, noncrossing dependency graphs can be found in time O(n 3 ), but cover only 48.23% of sentences in CCGBank ( Kuhlmann and Jonsson, 2015).We study two well-motivated restrictions to deep dependency graphs: (a) 1-endpoint-crossing (1EC hereafter; Pitler et al., 2013) and (b) pagenumber is less than or equal to 2 (P2 hereafter; Kuhlmann and Jonsson, 2015). We will show that if the output dependency graphs are restricted to satisfy both restrictions, the Maximum Subgraph problem can be solved using dynamic programming in time O(n 5 ). Moreover, if we ignore one linguistically-rare sub-problem, we can reduce the time complexity to O(n 4 ). Though this new algorithm is a degenerated one, it has the same empirical coverage for various deep dependency annotations. We evaluate the coverage of our algorithms on four linguistic data sets: CCGBank, DeepBank, Enju HPSGBank and Prague Dependency TreeBank. They cover 95.68%, 97.67%, 97.28% and 97.53% of dependency graphs in the four corpora. The relatively satisfactory coverage makes it possible to parse with high accuracy.Based on the quartic-time algorithm, we implement a parser with a discriminative disambiguation model. Our new parser can be taken as a graph-based parser which is complementary to transition-based ( Henderson et al., 2013;Zhang et al., 2016) and factorization-based (Mar- tins and Almeida, 2014;Du et al., 2015a) systems. We evaluate our parser on four data sets: those used in Task 8 (Oepen et al., 2014, and the dependency graphs extracted from CCGbank (Hockenmaier and Steed- man, 2007). Evaluations indicate that our parser produces very accurate deep dependency analysis. It reaches state-of-the-art results on average produced by a transition-based system of Zhang et al. (2016) and factorization-based systems (Martins and Almeida, 2014;Du et al., 2015a).The implementation of our parser is available at http://www.icst.pku.edu.cn/ lcwm/grass.</introduction>
<file>P17-1193-Figure8-1.png</file>
<figure>3</figure>
<caption>Figure 3: Decomposition for Int[i, j], with pt(i, k) = l.</caption>
<mention10>"..."</mention10>
<mention20>"..."</mention20>
<mention50>"..."</mention50>
<lines3>"</lines3>
<lines5>"</lines5>
<snippet3>"</snippet3>
<snippet5>"</snippet5>
<abstract>We study the Maximum Subgraph problem in deep dependency parsing. We consider two restrictions to deep dependency graphs: (a) 1-endpoint-crossing and (b) pagenumber-2. Our main contribution is an exact algorithm that obtains maximum subgraphs satisfying both restrictions simultaneously in time O(n 5). Moreover, ignoring one linguistically-rare structure descreases the complexity to O(n 4). We also extend our quartic-time algorithm into a practical parser with a discriminative dis-ambiguation model and evaluate its performance on four linguistic data sets used in semantic dependency parsing.</abstract>
<title>Parsing to 1-Endpoint-Crossing, Pagenumber-2 Graphs</title>
<introduction>Dependency parsing has long been studied as a central issue in developing syntactic or semantic analysis. Recently, some linguistic projects grounded on deep grammar formalisms, including CCG, LFG, and HPSG, draw attentions to rich syntactic and semantic dependency annotations that are not limited to trees (Hockenmaier and Steed- man, 2007;Ivanova et al., 2012). Parsing for these deep dependency representations can be viewed as the search for Maximum Subgraphs ( Kuhlmann and Jonsson, 2015). This is a natural extension of the Maximum Spanning Tree (MST) perspective (McDonald et al., 2005) for dependency tree parisng.One main challenge of the Maximum Subgraph perspective is to design tracTable algorithms for certain graph classes that have good empirical coverage for linguistic annotations. Unfortunately, no previously defined class simultaneously has high * The first two authors contribute equally.coverage and low-degree polynomial parsing algorithms. For example, noncrossing dependency graphs can be found in time O(n 3 ), but cover only 48.23% of sentences in CCGBank ( Kuhlmann and Jonsson, 2015).We study two well-motivated restrictions to deep dependency graphs: (a) 1-endpoint-crossing (1EC hereafter; Pitler et al., 2013) and (b) pagenumber is less than or equal to 2 (P2 hereafter; Kuhlmann and Jonsson, 2015). We will show that if the output dependency graphs are restricted to satisfy both restrictions, the Maximum Subgraph problem can be solved using dynamic programming in time O(n 5 ). Moreover, if we ignore one linguistically-rare sub-problem, we can reduce the time complexity to O(n 4 ). Though this new algorithm is a degenerated one, it has the same empirical coverage for various deep dependency annotations. We evaluate the coverage of our algorithms on four linguistic data sets: CCGBank, DeepBank, Enju HPSGBank and Prague Dependency TreeBank. They cover 95.68%, 97.67%, 97.28% and 97.53% of dependency graphs in the four corpora. The relatively satisfactory coverage makes it possible to parse with high accuracy.Based on the quartic-time algorithm, we implement a parser with a discriminative disambiguation model. Our new parser can be taken as a graph-based parser which is complementary to transition-based ( Henderson et al., 2013;Zhang et al., 2016) and factorization-based (Mar- tins and Almeida, 2014;Du et al., 2015a) systems. We evaluate our parser on four data sets: those used in Task 8 (Oepen et al., 2014, and the dependency graphs extracted from CCGbank (Hockenmaier and Steed- man, 2007). Evaluations indicate that our parser produces very accurate deep dependency analysis. It reaches state-of-the-art results on average produced by a transition-based system of Zhang et al. (2016) and factorization-based systems (Martins and Almeida, 2014;Du et al., 2015a).The implementation of our parser is available at http://www.icst.pku.edu.cn/ lcwm/grass.</introduction>
<file>P17-1193-Figure3-1.png</file>
<figure>5</figure>
<caption>Figure 5: Decomposition for N [i, j, x].</caption>
<mention10>"..."</mention10>
<mention20>"..."</mention20>
<mention50>"..."</mention50>
<lines3>"</lines3>
<lines5>"</lines5>
<snippet3>"</snippet3>
<snippet5>"</snippet5>
<abstract>We study the Maximum Subgraph problem in deep dependency parsing. We consider two restrictions to deep dependency graphs: (a) 1-endpoint-crossing and (b) pagenumber-2. Our main contribution is an exact algorithm that obtains maximum subgraphs satisfying both restrictions simultaneously in time O(n 5). Moreover, ignoring one linguistically-rare structure descreases the complexity to O(n 4). We also extend our quartic-time algorithm into a practical parser with a discriminative dis-ambiguation model and evaluate its performance on four linguistic data sets used in semantic dependency parsing.</abstract>
<title>Parsing to 1-Endpoint-Crossing, Pagenumber-2 Graphs</title>
<introduction>Dependency parsing has long been studied as a central issue in developing syntactic or semantic analysis. Recently, some linguistic projects grounded on deep grammar formalisms, including CCG, LFG, and HPSG, draw attentions to rich syntactic and semantic dependency annotations that are not limited to trees (Hockenmaier and Steed- man, 2007;Ivanova et al., 2012). Parsing for these deep dependency representations can be viewed as the search for Maximum Subgraphs ( Kuhlmann and Jonsson, 2015). This is a natural extension of the Maximum Spanning Tree (MST) perspective (McDonald et al., 2005) for dependency tree parisng.One main challenge of the Maximum Subgraph perspective is to design tracTable algorithms for certain graph classes that have good empirical coverage for linguistic annotations. Unfortunately, no previously defined class simultaneously has high * The first two authors contribute equally.coverage and low-degree polynomial parsing algorithms. For example, noncrossing dependency graphs can be found in time O(n 3 ), but cover only 48.23% of sentences in CCGBank ( Kuhlmann and Jonsson, 2015).We study two well-motivated restrictions to deep dependency graphs: (a) 1-endpoint-crossing (1EC hereafter; Pitler et al., 2013) and (b) pagenumber is less than or equal to 2 (P2 hereafter; Kuhlmann and Jonsson, 2015). We will show that if the output dependency graphs are restricted to satisfy both restrictions, the Maximum Subgraph problem can be solved using dynamic programming in time O(n 5 ). Moreover, if we ignore one linguistically-rare sub-problem, we can reduce the time complexity to O(n 4 ). Though this new algorithm is a degenerated one, it has the same empirical coverage for various deep dependency annotations. We evaluate the coverage of our algorithms on four linguistic data sets: CCGBank, DeepBank, Enju HPSGBank and Prague Dependency TreeBank. They cover 95.68%, 97.67%, 97.28% and 97.53% of dependency graphs in the four corpora. The relatively satisfactory coverage makes it possible to parse with high accuracy.Based on the quartic-time algorithm, we implement a parser with a discriminative disambiguation model. Our new parser can be taken as a graph-based parser which is complementary to transition-based ( Henderson et al., 2013;Zhang et al., 2016) and factorization-based (Mar- tins and Almeida, 2014;Du et al., 2015a) systems. We evaluate our parser on four data sets: those used in Task 8 (Oepen et al., 2014, and the dependency graphs extracted from CCGbank (Hockenmaier and Steed- man, 2007). Evaluations indicate that our parser produces very accurate deep dependency analysis. It reaches state-of-the-art results on average produced by a transition-based system of Zhang et al. (2016) and factorization-based systems (Martins and Almeida, 2014;Du et al., 2015a).The implementation of our parser is available at http://www.icst.pku.edu.cn/ lcwm/grass.</introduction>
<file>P17-1193-Figure5-1.png</file>
<figure>6</figure>
<caption>Figure 6: Decomposition for LR[i, j, x].</caption>
<mention10>"..."</mention10>
<mention20>"..."</mention20>
<mention50>"..."</mention50>
<lines3>"</lines3>
<lines5>"</lines5>
<snippet3>"</snippet3>
<snippet5>"</snippet5>
<abstract>We study the Maximum Subgraph problem in deep dependency parsing. We consider two restrictions to deep dependency graphs: (a) 1-endpoint-crossing and (b) pagenumber-2. Our main contribution is an exact algorithm that obtains maximum subgraphs satisfying both restrictions simultaneously in time O(n 5). Moreover, ignoring one linguistically-rare structure descreases the complexity to O(n 4). We also extend our quartic-time algorithm into a practical parser with a discriminative dis-ambiguation model and evaluate its performance on four linguistic data sets used in semantic dependency parsing.</abstract>
<title>Parsing to 1-Endpoint-Crossing, Pagenumber-2 Graphs</title>
<introduction>Dependency parsing has long been studied as a central issue in developing syntactic or semantic analysis. Recently, some linguistic projects grounded on deep grammar formalisms, including CCG, LFG, and HPSG, draw attentions to rich syntactic and semantic dependency annotations that are not limited to trees (Hockenmaier and Steed- man, 2007;Ivanova et al., 2012). Parsing for these deep dependency representations can be viewed as the search for Maximum Subgraphs ( Kuhlmann and Jonsson, 2015). This is a natural extension of the Maximum Spanning Tree (MST) perspective (McDonald et al., 2005) for dependency tree parisng.One main challenge of the Maximum Subgraph perspective is to design tracTable algorithms for certain graph classes that have good empirical coverage for linguistic annotations. Unfortunately, no previously defined class simultaneously has high * The first two authors contribute equally.coverage and low-degree polynomial parsing algorithms. For example, noncrossing dependency graphs can be found in time O(n 3 ), but cover only 48.23% of sentences in CCGBank ( Kuhlmann and Jonsson, 2015).We study two well-motivated restrictions to deep dependency graphs: (a) 1-endpoint-crossing (1EC hereafter; Pitler et al., 2013) and (b) pagenumber is less than or equal to 2 (P2 hereafter; Kuhlmann and Jonsson, 2015). We will show that if the output dependency graphs are restricted to satisfy both restrictions, the Maximum Subgraph problem can be solved using dynamic programming in time O(n 5 ). Moreover, if we ignore one linguistically-rare sub-problem, we can reduce the time complexity to O(n 4 ). Though this new algorithm is a degenerated one, it has the same empirical coverage for various deep dependency annotations. We evaluate the coverage of our algorithms on four linguistic data sets: CCGBank, DeepBank, Enju HPSGBank and Prague Dependency TreeBank. They cover 95.68%, 97.67%, 97.28% and 97.53% of dependency graphs in the four corpora. The relatively satisfactory coverage makes it possible to parse with high accuracy.Based on the quartic-time algorithm, we implement a parser with a discriminative disambiguation model. Our new parser can be taken as a graph-based parser which is complementary to transition-based ( Henderson et al., 2013;Zhang et al., 2016) and factorization-based (Mar- tins and Almeida, 2014;Du et al., 2015a) systems. We evaluate our parser on four data sets: those used in Task 8 (Oepen et al., 2014, and the dependency graphs extracted from CCGbank (Hockenmaier and Steed- man, 2007). Evaluations indicate that our parser produces very accurate deep dependency analysis. It reaches state-of-the-art results on average produced by a transition-based system of Zhang et al. (2016) and factorization-based systems (Martins and Almeida, 2014;Du et al., 2015a).The implementation of our parser is available at http://www.icst.pku.edu.cn/ lcwm/grass.</introduction>
<file>P17-1193-Figure6-1.png</file>
<figure>4</figure>
<caption>Figure 4: Decomposition for L[i, j, x].</caption>
<mention10>"..."</mention10>
<mention20>"..."</mention20>
<mention50>"..."</mention50>
<lines3>"</lines3>
<lines5>"</lines5>
<snippet3>"</snippet3>
<snippet5>"</snippet5>
<abstract>We study the Maximum Subgraph problem in deep dependency parsing. We consider two restrictions to deep dependency graphs: (a) 1-endpoint-crossing and (b) pagenumber-2. Our main contribution is an exact algorithm that obtains maximum subgraphs satisfying both restrictions simultaneously in time O(n 5). Moreover, ignoring one linguistically-rare structure descreases the complexity to O(n 4). We also extend our quartic-time algorithm into a practical parser with a discriminative dis-ambiguation model and evaluate its performance on four linguistic data sets used in semantic dependency parsing.</abstract>
<title>Parsing to 1-Endpoint-Crossing, Pagenumber-2 Graphs</title>
<introduction>Dependency parsing has long been studied as a central issue in developing syntactic or semantic analysis. Recently, some linguistic projects grounded on deep grammar formalisms, including CCG, LFG, and HPSG, draw attentions to rich syntactic and semantic dependency annotations that are not limited to trees (Hockenmaier and Steed- man, 2007;Ivanova et al., 2012). Parsing for these deep dependency representations can be viewed as the search for Maximum Subgraphs ( Kuhlmann and Jonsson, 2015). This is a natural extension of the Maximum Spanning Tree (MST) perspective (McDonald et al., 2005) for dependency tree parisng.One main challenge of the Maximum Subgraph perspective is to design tracTable algorithms for certain graph classes that have good empirical coverage for linguistic annotations. Unfortunately, no previously defined class simultaneously has high * The first two authors contribute equally.coverage and low-degree polynomial parsing algorithms. For example, noncrossing dependency graphs can be found in time O(n 3 ), but cover only 48.23% of sentences in CCGBank ( Kuhlmann and Jonsson, 2015).We study two well-motivated restrictions to deep dependency graphs: (a) 1-endpoint-crossing (1EC hereafter; Pitler et al., 2013) and (b) pagenumber is less than or equal to 2 (P2 hereafter; Kuhlmann and Jonsson, 2015). We will show that if the output dependency graphs are restricted to satisfy both restrictions, the Maximum Subgraph problem can be solved using dynamic programming in time O(n 5 ). Moreover, if we ignore one linguistically-rare sub-problem, we can reduce the time complexity to O(n 4 ). Though this new algorithm is a degenerated one, it has the same empirical coverage for various deep dependency annotations. We evaluate the coverage of our algorithms on four linguistic data sets: CCGBank, DeepBank, Enju HPSGBank and Prague Dependency TreeBank. They cover 95.68%, 97.67%, 97.28% and 97.53% of dependency graphs in the four corpora. The relatively satisfactory coverage makes it possible to parse with high accuracy.Based on the quartic-time algorithm, we implement a parser with a discriminative disambiguation model. Our new parser can be taken as a graph-based parser which is complementary to transition-based ( Henderson et al., 2013;Zhang et al., 2016) and factorization-based (Mar- tins and Almeida, 2014;Du et al., 2015a) systems. We evaluate our parser on four data sets: those used in Task 8 (Oepen et al., 2014, and the dependency graphs extracted from CCGbank (Hockenmaier and Steed- man, 2007). Evaluations indicate that our parser produces very accurate deep dependency analysis. It reaches state-of-the-art results on average produced by a transition-based system of Zhang et al. (2016) and factorization-based systems (Martins and Almeida, 2014;Du et al., 2015a).The implementation of our parser is available at http://www.icst.pku.edu.cn/ lcwm/grass.</introduction>
<file>P17-1193-Figure4-1.png</file>