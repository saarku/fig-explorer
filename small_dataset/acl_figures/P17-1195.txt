<figure>1</figure>
<caption>Figure 1: Example problem</caption>
<mention10>"... of P that gives the maximum area. (Hokkaido Univ., 1999-Sci-3) Figure 1: Example problem search themes in natural language processing. The ..."</mention10>
<mention20>"... maximum area of the triangle P QR and the coordinates of P that gives the maximum area. (Hokkaido Univ., 1999-Sci-3) Figure 1: Example problem search themes in natural language processing. The conceptual basis has been laid down, which connects text to ..."</mention20>
<mention50>"... Assuming that the distance between the two points Q and R is 2, find the locus C of P . (3) When the point P moves on C, find the maximum area of the triangle P QR and the coordinates of P that gives the maximum area. (Hokkaido Univ., 1999-Sci-3) Figure 1: Example problem search themes in natural language processing. The conceptual basis has been laid down, which connects text to the truth (= answer) through reasoning. However, we have not seen a fully automated system that instantiates it end-to-end. We wish to add a piece to the big picture by ..."</mention50>
<lines3> (3) When the point P moves on C, find the maximum area of the triangle P QR and the coordinates of P that gives the maximum area. (Hokkaido Univ., 1999-Sci-3) Figure 1: Example problem search themes in natural language processing. The conceptual basis has been laid down, which connects text to the truth (= answer) through reasoning. ...  The subject areas include real and linear algebra, complex numbers, calculus, and geometry. Furthermore, many problems involve more than one subject: e.g., algebraic curves and calculus as in Fig 1. Their logical forms include all the logical connectives, quantifiers, and λ-abstraction"</lines3>
<lines5> (2) Assuming that the distance between the two points Q and R is 2, find the locus C of P . (3) When the point P moves on C, find the maximum area of the triangle P QR and the coordinates of P that gives the maximum area. (Hokkaido Univ., 1999-Sci-3) Figure 1: Example problem search themes in natural language processing. The conceptual basis has been laid down, which connects text to the truth (= answer) through reasoning. However, we have not seen a fully automated system that instantiates it end-to-end. ...  1n §3, we will show that none of them includes ∀ (for all), ∨ (or) or → (implies  We take pre-university math problems falling in the theory of real-closed fields (RCF) as our benchmark because of their variety and complexity. The subject areas include real and linear algebra, complex numbers, calculus, and geometry. Furthermore, many problems involve more than one subject: e.g., algebraic curves and calculus as in Fig 1. Their logical forms include all the logical connectives, quantifiers, and λ-abstraction. Our goal is to recognize the complex logical structures precisely, including the scopes of the quantifiers and other logical operators"</lines5>
<snippet3> (3) When the point P moves on C, find the maximum area of the triangle P QR and the coordinates of P that gives the maximum area. (Hokkaido Univ., 1999-Sci-3) Figure 1: Example problem search themes in natural language processing. The conceptual basis has been laid down, which connects text to the truth (= answer) through reasoning.</snippet3>
<snippet5> (2) Assuming that the distance between the two points Q and R is 2, find the locus C of P . (3) When the point P moves on C, find the maximum area of the triangle P QR and the coordinates of P that gives the maximum area. (Hokkaido Univ., 1999-Sci-3) Figure 1: Example problem search themes in natural language processing. The conceptual basis has been laid down, which connects text to the truth (= answer) through reasoning. However, we have not seen a fully automated system that instantiates it end-to-end.</snippet5>
<abstract>We have been developing an end-to-end math problem solving system that accepts natural language input. The current paper focuses on how we analyze the problem sentences to produce logical forms. We chose a hybrid approach combining a shallow syntactic analyzer and a manually-developed lexicalized grammar. A feature of the grammar is that it is extensively typed on the basis of a formal ontology for pre-university math. These types are helpful in semantic disambiguation inside and across sentences. Experimental results show that the hybrid system produces a well-formed logical form with 88% precision and 56% recall.</abstract>
<title>Semantic Parsing of Pre-university Math Problems</title>
<introduction>Frege and Russell, the initiators of the mathematical logic, delved also into the exploration of a theory of natural language semantics (Frege, 1892;Russell, 1905). Since then, symbolic logic has been a fundamental tool and a source of inspiration in the study of language meaning. It suggests that the formalization of the two realms, mathematical reasoning and language meaning, is actually the two sides of the same coin -probably, we could not even conceive the idea of formalizing language meaning without grounding it onto mathematical reasoning. This point was first clarified by Tarski (1936;1944) mainly on formal languages and then extended to natural languages by Davidson (1967). Montague (1970a;1970b;1973) further embodied it by putting forward a terrifyingly arrogant and attractive idea of seeing a natural language as a formal language.The automation of end-to-end math problem solving thus has an outstanding status in the reDefine the two straight lines L1 and L2 on the xy-plane as L1: y = 0 (x-axis) and L2: y = √ 3x. Let P be a point on the xy-plane. Let Q be the point symmetric to P about the straight line L1, and let R be the point symmetric to P about the straight line L2. Answer the following questions:(1) Let (a, b) be the coordinates of P , then represent the coordinates of R using a and b. (2) Assuming that the distance between the two points Q and R is 2, find the locus C of P . (3) When the point P moves on C, find the maximum area of the triangle P QR and the coordinates of P that gives the maximum area.(Hokkaido Univ., 1999-Sci-3) Figure 1: Example problem search themes in natural language processing. The conceptual basis has been laid down, which connects text to the truth (= answer) through reasoning. However, we have not seen a fully automated system that instantiates it end-to-end. We wish to add a piece to the big picture by materializing it. Past studies have mainly targeted at primary school level arithmetic word problems (Bobrow, 1964;Charniak, 1969;Hos- seini et al., 2014;Shi et al., 2015;Roy and Roth, 2015;Zhou et al., 2015;Koncel-Kedziorski et al., 2015;Mitra and Baral, 2016;Upadhyay et al., 2016). In their nature, arithmetic questions are quantifier-free. Moreover they tend to include only ∧ (and) as the logical connective. The main challenge in these works was to extract simple numerical relations (most typically equations) from a real-world scenario described in a text. Seo et al. (2015) took SAT geometry questions as their benchmark. However, the nature of SAT geometry questions restricts the resulting formula's complexity. In §3, we will show that none of them includes ∀ (for all), ∨ (or) or → (implies  We take pre-university math problems falling in the theory of real-closed fields (RCF) as our benchmark because of their variety and complexity. The subject areas include real and linear algebra, complex numbers, calculus, and geometry. Furthermore, many problems involve more than one subject: e.g., algebraic curves and calculus as in Fig. 1. Their logical forms include all the logical connectives, quantifiers, and λ-abstraction. Our goal is to recognize the complex logical structures precisely, including the scopes of the quantifiers and other logical operators.In the rest of the paper, we first present an overview of an end-to-end problem solving system ( §2) and analyze the complexity of the preuniversity math benchmark in comparison with others ( §3). Among the modules in the end-to-end system, we focus on the sentence-level semantic parsing component and describe an extensivelytyped grammar ( §4 and §5), an analyzer for the math expressions in the text ( §6), and two semantic parsing techniques to fight against the scarcity of the training data ( §7) and the complexity of the domain ( §8). Experimental results show the effectiveness of the presented techniques as well as the complexity of the task through an in-depth analysis of the end-to-end problem solving results ( §9).2 End-to-end Math Problem Solving Fig. 2 presents an overview of our end-to-end math problem solving system. A math problem text is firstly analyzed with a dependency parser. Anaphoric and coreferential expressions in the text are then identified and their antecedents are determined. We assume the math formulas in the problems are encoded in MathML presentation mark-up. A specialized parser processes each one of them to determine its syntactic category and semantic content. The semantic representation of each sentence is determined by a semantic parser based on Combinatory Categorial Grammar (CCG) (Steedman, 2001(Steedman, , 2012  Table 1: Performance of the reasoning module on manually formalized pre-university problemsAfter the sentence-level processing steps, we determine the logical relations among the sentence-level logical forms (discourse parsing) by a simple rule-based system. It produces a tree structure whose leaves are labeled with sentences and internal nodes with logical connectives. Free variables in the logical form are then bound by some quantifiers (or kept free) and their scopes are determined according to the logical structure of the problem. A semantic representation of a problem is obtained as a formula in a higher-order logic through these language analysis steps.The logical representation is then rewritten using a set of axioms that define the meanings of the predicate and function symbols in the formula, such as maximum defined as follows:as well as several logical rules such as β-reduction. We hope to obtain a representation of the initial problem expressed in a decidable math theory such as RCF through these equivalencepreserving rewriting. Once we find such a formula, we invoke a computer algebra system (CAS) or an automatic theorem prover (ATP) to derive the answer.The reasoning module (i.e., the formula rewriting and the deduction with CAS and ATP) of the system has been extensively tested on a large collection of manually formalized pre-university math problems that includes more than 1,500 problems. It solves 70% of the them in the time limit of 10 minutes per problem. Table 1 shows the rate of successfully solved problems in the manually formalized version of the benchmark problems used in the current paper.</introduction>
<file>P17-1195-Figure1-1.png</file>
<figure>3</figure>
<caption>Figure 3: Sketch of the derivation tree for a sentence including an action verb and quantification</caption>
<mention10>"... (∃k; k ∈ K) → quo of(quorem(k, m)) = 3 Figure 3: Sketch of the derivation tree for a sentence including ..."</mention10>
<mention20>"... 3. S\N P : λx.quo of(x) = 3 S : (∃k; k ∈ K) → quo of(quorem(k, m)) = 3 Figure 3: Sketch of the derivation tree for a sentence including an action verb and quantification phrases is expressed by polymorphic ..."</mention20>
<mention50>"... pronoun φ has 'the result of division n/m' as its antecedent but not (n, m). Polymorphism is a mandatory part of the language. Especially, the semantics of plural noun is 3. S\N P : λx.quo of(x) = 3 S : (∃k; k ∈ K) → quo of(quorem(k, m)) = 3 Figure 3: Sketch of the derivation tree for a sentence including an action verb and quantification phrases is expressed by polymorphic lists and tuples: e.g., 'the radii of the circles C 1 , C 2 , and C 3 ' is of type ListOf(R) and 'the function f and its maximum ..."</mention50>
<lines3> Especially, the semantics of plural noun is 3. S\N P : λx.quo of(x) = 3 S : (∃k; k ∈ K) → quo of(quorem(k, m)) = 3 Figure 3: Sketch of the derivation tree for a sentence including an action verb and quantification phrases is expressed by polymorphic lists and tuples: e.g., 'the radii of the circles C 1 , C 2 , and C 3 ' is of type ListOf(R) and 'the function f and its maximum value' is of type Pair(R2R,R). An instance of CCG grammar consists of a lexicon and a small number of combinatory rules. ...  To handle such phenomena, we posit the semantic type of Sa as Pair(α, Bool) where the two components respectively bring the result of an action and the condition on it (including quantification). Fig 3 presents a derivation tree for the above example. 4 The atomic category NP, N, and Sa in our grammar have type feature"</lines3>
<lines5> Polymorphism is a mandatory part of the language. Especially, the semantics of plural noun is 3. S\N P : λx.quo of(x) = 3 S : (∃k; k ∈ K) → quo of(quorem(k, m)) = 3 Figure 3: Sketch of the derivation tree for a sentence including an action verb and quantification phrases is expressed by polymorphic lists and tuples: e.g., 'the radii of the circles C 1 , C 2 , and C 3 ' is of type ListOf(R) and 'the function f and its maximum value' is of type Pair(R2R,R). An instance of CCG grammar consists of a lexicon and a small number of combinatory rules. A lexicon is a set of lexical items, each of which associates a word surface form with a syntactic category and a semantic function: e.g., A syntactic category is one of atomic categories, such as NP, PP, and S, or a complex category in the form of X/Y or X\Y, where X and Y are syntactic categories. ...  The action verbs can also mediate quantification as in: When any k ∈K is divided by m, the quotient is 3. where quorem(k, m) represents the result of the division (i.e., the pair of the quotient and the remainder) and quo of is a function that extracts the quotient from it. To handle such phenomena, we posit the semantic type of Sa as Pair(α, Bool) where the two components respectively bring the result of an action and the condition on it (including quantification). Fig 3 presents a derivation tree for the above example. 4 The atomic category NP, N, and Sa in our grammar have type feature. 1ts value is one of the types defined in the semantic language or a type variable when the entity type is underspecified"</lines5>
<snippet3> Especially, the semantics of plural noun is 3. S\N P : λx.quo of(x) = 3 S : (∃k; k ∈ K) → quo of(quorem(k, m)) = 3 Figure 3: Sketch of the derivation tree for a sentence including an action verb and quantification phrases is expressed by polymorphic lists and tuples: e.g., 'the radii of the circles C 1 , C 2 , and C 3 ' is of type ListOf(R) and 'the function f and its maximum value' is of type Pair(R2R,R). An instance of CCG grammar consists of a lexicon and a small number of combinatory rules.</snippet3>
<snippet5> Polymorphism is a mandatory part of the language. Especially, the semantics of plural noun is 3. S\N P : λx.quo of(x) = 3 S : (∃k; k ∈ K) → quo of(quorem(k, m)) = 3 Figure 3: Sketch of the derivation tree for a sentence including an action verb and quantification phrases is expressed by polymorphic lists and tuples: e.g., 'the radii of the circles C 1 , C 2 , and C 3 ' is of type ListOf(R) and 'the function f and its maximum value' is of type Pair(R2R,R). An instance of CCG grammar consists of a lexicon and a small number of combinatory rules. A lexicon is a set of lexical items, each of which associates a word surface form with a syntactic category and a semantic function: e.g., A syntactic category is one of atomic categories, such as NP, PP, and S, or a complex category in the form of X/Y or X\Y, where X and Y are syntactic categories.</snippet5>
<abstract>We have been developing an end-to-end math problem solving system that accepts natural language input. The current paper focuses on how we analyze the problem sentences to produce logical forms. We chose a hybrid approach combining a shallow syntactic analyzer and a manually-developed lexicalized grammar. A feature of the grammar is that it is extensively typed on the basis of a formal ontology for pre-university math. These types are helpful in semantic disambiguation inside and across sentences. Experimental results show that the hybrid system produces a well-formed logical form with 88% precision and 56% recall.</abstract>
<title>Semantic Parsing of Pre-university Math Problems</title>
<introduction>Frege and Russell, the initiators of the mathematical logic, delved also into the exploration of a theory of natural language semantics (Frege, 1892;Russell, 1905). Since then, symbolic logic has been a fundamental tool and a source of inspiration in the study of language meaning. It suggests that the formalization of the two realms, mathematical reasoning and language meaning, is actually the two sides of the same coin -probably, we could not even conceive the idea of formalizing language meaning without grounding it onto mathematical reasoning. This point was first clarified by Tarski (1936;1944) mainly on formal languages and then extended to natural languages by Davidson (1967). Montague (1970a;1970b;1973) further embodied it by putting forward a terrifyingly arrogant and attractive idea of seeing a natural language as a formal language.The automation of end-to-end math problem solving thus has an outstanding status in the reDefine the two straight lines L1 and L2 on the xy-plane as L1: y = 0 (x-axis) and L2: y = √ 3x. Let P be a point on the xy-plane. Let Q be the point symmetric to P about the straight line L1, and let R be the point symmetric to P about the straight line L2. Answer the following questions:(1) Let (a, b) be the coordinates of P , then represent the coordinates of R using a and b. (2) Assuming that the distance between the two points Q and R is 2, find the locus C of P . (3) When the point P moves on C, find the maximum area of the triangle P QR and the coordinates of P that gives the maximum area.(Hokkaido Univ., 1999-Sci-3) Figure 1: Example problem search themes in natural language processing. The conceptual basis has been laid down, which connects text to the truth (= answer) through reasoning. However, we have not seen a fully automated system that instantiates it end-to-end. We wish to add a piece to the big picture by materializing it. Past studies have mainly targeted at primary school level arithmetic word problems (Bobrow, 1964;Charniak, 1969;Hos- seini et al., 2014;Shi et al., 2015;Roy and Roth, 2015;Zhou et al., 2015;Koncel-Kedziorski et al., 2015;Mitra and Baral, 2016;Upadhyay et al., 2016). In their nature, arithmetic questions are quantifier-free. Moreover they tend to include only ∧ (and) as the logical connective. The main challenge in these works was to extract simple numerical relations (most typically equations) from a real-world scenario described in a text. Seo et al. (2015) took SAT geometry questions as their benchmark. However, the nature of SAT geometry questions restricts the resulting formula's complexity. In §3, we will show that none of them includes ∀ (for all), ∨ (or) or → (implies  We take pre-university math problems falling in the theory of real-closed fields (RCF) as our benchmark because of their variety and complexity. The subject areas include real and linear algebra, complex numbers, calculus, and geometry. Furthermore, many problems involve more than one subject: e.g., algebraic curves and calculus as in Fig. 1. Their logical forms include all the logical connectives, quantifiers, and λ-abstraction. Our goal is to recognize the complex logical structures precisely, including the scopes of the quantifiers and other logical operators.In the rest of the paper, we first present an overview of an end-to-end problem solving system ( §2) and analyze the complexity of the preuniversity math benchmark in comparison with others ( §3). Among the modules in the end-to-end system, we focus on the sentence-level semantic parsing component and describe an extensivelytyped grammar ( §4 and §5), an analyzer for the math expressions in the text ( §6), and two semantic parsing techniques to fight against the scarcity of the training data ( §7) and the complexity of the domain ( §8). Experimental results show the effectiveness of the presented techniques as well as the complexity of the task through an in-depth analysis of the end-to-end problem solving results ( §9).2 End-to-end Math Problem Solving Fig. 2 presents an overview of our end-to-end math problem solving system. A math problem text is firstly analyzed with a dependency parser. Anaphoric and coreferential expressions in the text are then identified and their antecedents are determined. We assume the math formulas in the problems are encoded in MathML presentation mark-up. A specialized parser processes each one of them to determine its syntactic category and semantic content. The semantic representation of each sentence is determined by a semantic parser based on Combinatory Categorial Grammar (CCG) (Steedman, 2001(Steedman, , 2012  Table 1: Performance of the reasoning module on manually formalized pre-university problemsAfter the sentence-level processing steps, we determine the logical relations among the sentence-level logical forms (discourse parsing) by a simple rule-based system. It produces a tree structure whose leaves are labeled with sentences and internal nodes with logical connectives. Free variables in the logical form are then bound by some quantifiers (or kept free) and their scopes are determined according to the logical structure of the problem. A semantic representation of a problem is obtained as a formula in a higher-order logic through these language analysis steps.The logical representation is then rewritten using a set of axioms that define the meanings of the predicate and function symbols in the formula, such as maximum defined as follows:as well as several logical rules such as β-reduction. We hope to obtain a representation of the initial problem expressed in a decidable math theory such as RCF through these equivalencepreserving rewriting. Once we find such a formula, we invoke a computer algebra system (CAS) or an automatic theorem prover (ATP) to derive the answer.The reasoning module (i.e., the formula rewriting and the deduction with CAS and ATP) of the system has been extensively tested on a large collection of manually formalized pre-university math problems that includes more than 1,500 problems. It solves 70% of the them in the time limit of 10 minutes per problem. Table 1 shows the rate of successfully solved problems in the manually formalized version of the benchmark problems used in the current paper.</introduction>
<file>P17-1195-Figure3-1.png</file>
<figure>5</figure>
<caption>Figure 5: Restricted CKY parsing based on a shallow dependency structure</caption>
<mention10>"... w 4 w 5 w 6 w 7 w 8 Figure 5: Restricted CKY parsing based on a shallow dependency structure ..."</mention10>
<mention20>"... span from i-th to w 1 w 2 w 3 w 4 w 5 w 6 w 7 w 8 Figure 5: Restricted CKY parsing based on a shallow dependency structure (i+k-1)-th words. Under the two assumptions, we only need to ..."</mention20>
<mention50>"... of four bunsetsus (rounded squares), each of which contains two words. In the figure, the i-th cell in the k-th row from the bottom is the CKY cell for the span from i-th to w 1 w 2 w 3 w 4 w 5 w 6 w 7 w 8 Figure 5: Restricted CKY parsing based on a shallow dependency structure (i+k-1)-th words. Under the two assumptions, we only need to fill the hatched cells given the dependency structure shown below the CKY chart. The hatched cells with a white circle indicate the positions of the matching nodes. Even under the ..."</mention50>
<lines3> We further assume: (ii) a matching node is combined with another CCG tree node whose span includes at least one word in the head bunsetsu of the matching node. Fig 5 presents an example of a sentence consisting of four bunsetsus (rounded squares), each of which contains two words. 1n the figure, the i-th cell in the k-th row from the bottom is the CKY cell for the span from i-th to w 1 w 2 w 3 w 4 w 5 w 6 w 7 w 8 Figure 5: Restricted CKY parsing based on a shallow dependency structure (i+k-1)-th words. Under the two assumptions, we only need to fill the hatched cells given the dependency structure shown below the CKY chart"</lines3>
<lines5> We call such a node in the CCG tree 'a matching node.' We further assume: (ii) a matching node is combined with another CCG tree node whose span includes at least one word in the head bunsetsu of the matching node. Fig 5 presents an example of a sentence consisting of four bunsetsus (rounded squares), each of which contains two words. 1n the figure, the i-th cell in the k-th row from the bottom is the CKY cell for the span from i-th to w 1 w 2 w 3 w 4 w 5 w 6 w 7 w 8 Figure 5: Restricted CKY parsing based on a shallow dependency structure (i+k-1)-th words. Under the two assumptions, we only need to fill the hatched cells given the dependency structure shown below the CKY chart. The hatched cells with a white circle indicate the positions of the matching nodes"</lines5>
<snippet3> We further assume: (ii) a matching node is combined with another CCG tree node whose span includes at least one word in the head bunsetsu of the matching node. Fig 5 presents an example of a sentence consisting of four bunsetsus (rounded squares), each of which contains two words. 1n the figure, the i-th cell in the k-th row from the bottom is the CKY cell for the span from i-th to w 1 w 2 w 3 w 4 w 5 w 6 w 7 w 8 Figure 5: Restricted CKY parsing based on a shallow dependency structure (i+k-1)-th words. Under the two assumptions, we only need to fill the hatched cells given the dependency structure shown below the CKY chart"</snippet3>
<snippet5> We call such a node in the CCG tree 'a matching node.' We further assume: (ii) a matching node is combined with another CCG tree node whose span includes at least one word in the head bunsetsu of the matching node. Fig 5 presents an example of a sentence consisting of four bunsetsus (rounded squares), each of which contains two words. 1n the figure, the i-th cell in the k-th row from the bottom is the CKY cell for the span from i-th to w 1 w 2 w 3 w 4 w 5 w 6 w 7 w 8 Figure 5: Restricted CKY parsing based on a shallow dependency structure (i+k-1)-th words. Under the two assumptions, we only need to fill the hatched cells given the dependency structure shown below the CKY chart. The hatched cells with a white circle indicate the positions of the matching nodes"</snippet5>
<abstract>We have been developing an end-to-end math problem solving system that accepts natural language input. The current paper focuses on how we analyze the problem sentences to produce logical forms. We chose a hybrid approach combining a shallow syntactic analyzer and a manually-developed lexicalized grammar. A feature of the grammar is that it is extensively typed on the basis of a formal ontology for pre-university math. These types are helpful in semantic disambiguation inside and across sentences. Experimental results show that the hybrid system produces a well-formed logical form with 88% precision and 56% recall.</abstract>
<title>Semantic Parsing of Pre-university Math Problems</title>
<introduction>Frege and Russell, the initiators of the mathematical logic, delved also into the exploration of a theory of natural language semantics (Frege, 1892;Russell, 1905). Since then, symbolic logic has been a fundamental tool and a source of inspiration in the study of language meaning. It suggests that the formalization of the two realms, mathematical reasoning and language meaning, is actually the two sides of the same coin -probably, we could not even conceive the idea of formalizing language meaning without grounding it onto mathematical reasoning. This point was first clarified by Tarski (1936;1944) mainly on formal languages and then extended to natural languages by Davidson (1967). Montague (1970a;1970b;1973) further embodied it by putting forward a terrifyingly arrogant and attractive idea of seeing a natural language as a formal language.The automation of end-to-end math problem solving thus has an outstanding status in the reDefine the two straight lines L1 and L2 on the xy-plane as L1: y = 0 (x-axis) and L2: y = √ 3x. Let P be a point on the xy-plane. Let Q be the point symmetric to P about the straight line L1, and let R be the point symmetric to P about the straight line L2. Answer the following questions:(1) Let (a, b) be the coordinates of P , then represent the coordinates of R using a and b. (2) Assuming that the distance between the two points Q and R is 2, find the locus C of P . (3) When the point P moves on C, find the maximum area of the triangle P QR and the coordinates of P that gives the maximum area.(Hokkaido Univ., 1999-Sci-3) Figure 1: Example problem search themes in natural language processing. The conceptual basis has been laid down, which connects text to the truth (= answer) through reasoning. However, we have not seen a fully automated system that instantiates it end-to-end. We wish to add a piece to the big picture by materializing it. Past studies have mainly targeted at primary school level arithmetic word problems (Bobrow, 1964;Charniak, 1969;Hos- seini et al., 2014;Shi et al., 2015;Roy and Roth, 2015;Zhou et al., 2015;Koncel-Kedziorski et al., 2015;Mitra and Baral, 2016;Upadhyay et al., 2016). In their nature, arithmetic questions are quantifier-free. Moreover they tend to include only ∧ (and) as the logical connective. The main challenge in these works was to extract simple numerical relations (most typically equations) from a real-world scenario described in a text. Seo et al. (2015) took SAT geometry questions as their benchmark. However, the nature of SAT geometry questions restricts the resulting formula's complexity. In §3, we will show that none of them includes ∀ (for all), ∨ (or) or → (implies  We take pre-university math problems falling in the theory of real-closed fields (RCF) as our benchmark because of their variety and complexity. The subject areas include real and linear algebra, complex numbers, calculus, and geometry. Furthermore, many problems involve more than one subject: e.g., algebraic curves and calculus as in Fig. 1. Their logical forms include all the logical connectives, quantifiers, and λ-abstraction. Our goal is to recognize the complex logical structures precisely, including the scopes of the quantifiers and other logical operators.In the rest of the paper, we first present an overview of an end-to-end problem solving system ( §2) and analyze the complexity of the preuniversity math benchmark in comparison with others ( §3). Among the modules in the end-to-end system, we focus on the sentence-level semantic parsing component and describe an extensivelytyped grammar ( §4 and §5), an analyzer for the math expressions in the text ( §6), and two semantic parsing techniques to fight against the scarcity of the training data ( §7) and the complexity of the domain ( §8). Experimental results show the effectiveness of the presented techniques as well as the complexity of the task through an in-depth analysis of the end-to-end problem solving results ( §9).2 End-to-end Math Problem Solving Fig. 2 presents an overview of our end-to-end math problem solving system. A math problem text is firstly analyzed with a dependency parser. Anaphoric and coreferential expressions in the text are then identified and their antecedents are determined. We assume the math formulas in the problems are encoded in MathML presentation mark-up. A specialized parser processes each one of them to determine its syntactic category and semantic content. The semantic representation of each sentence is determined by a semantic parser based on Combinatory Categorial Grammar (CCG) (Steedman, 2001(Steedman, , 2012  Table 1: Performance of the reasoning module on manually formalized pre-university problemsAfter the sentence-level processing steps, we determine the logical relations among the sentence-level logical forms (discourse parsing) by a simple rule-based system. It produces a tree structure whose leaves are labeled with sentences and internal nodes with logical connectives. Free variables in the logical form are then bound by some quantifiers (or kept free) and their scopes are determined according to the logical structure of the problem. A semantic representation of a problem is obtained as a formula in a higher-order logic through these language analysis steps.The logical representation is then rewritten using a set of axioms that define the meanings of the predicate and function symbols in the formula, such as maximum defined as follows:as well as several logical rules such as β-reduction. We hope to obtain a representation of the initial problem expressed in a decidable math theory such as RCF through these equivalencepreserving rewriting. Once we find such a formula, we invoke a computer algebra system (CAS) or an automatic theorem prover (ATP) to derive the answer.The reasoning module (i.e., the formula rewriting and the deduction with CAS and ATP) of the system has been extensively tested on a large collection of manually formalized pre-university math problems that includes more than 1,500 problems. It solves 70% of the them in the time limit of 10 minutes per problem. Table 1 shows the rate of successfully solved problems in the manually formalized version of the benchmark problems used in the current paper.</introduction>
<file>P17-1195-Figure5-1.png</file>
<figure>2</figure>
<caption>Figure 2: Overview of the end-to-end math problem solving system</caption>
<mention10>"..."</mention10>
<mention20>"..."</mention20>
<mention50>"..."</mention50>
<lines3> Experimental results show the effectiveness of the presented techniques as well as the complexity of the task through an in-depth analysis of the end-to-end problem solving results ( §9). 2 End-to-end Math Problem Solving Fig 2 presents an overview of our end-to-end math problem solving system. A math problem text is firstly analyzed with a dependency parser"</lines3>
<lines5> Among the modules in the end-to-end system, we focus on the sentence-level semantic parsing component and describe an extensivelytyped grammar ( §4 and §5), an analyzer for the math expressions in the text ( §6), and two semantic parsing techniques to fight against the scarcity of the training data ( §7) and the complexity of the domain ( §8). Experimental results show the effectiveness of the presented techniques as well as the complexity of the task through an in-depth analysis of the end-to-end problem solving results ( §9). 2 End-to-end Math Problem Solving Fig 2 presents an overview of our end-to-end math problem solving system. A math problem text is firstly analyzed with a dependency parser. Anaphoric and coreferential expressions in the text are then identified and their antecedents are determined"</lines5>
<snippet3> Experimental results show the effectiveness of the presented techniques as well as the complexity of the task through an in-depth analysis of the end-to-end problem solving results ( §9). 2 End-to-end Math Problem Solving Fig 2 presents an overview of our end-to-end math problem solving system. A math problem text is firstly analyzed with a dependency parser"</snippet3>
<snippet5> Among the modules in the end-to-end system, we focus on the sentence-level semantic parsing component and describe an extensivelytyped grammar ( §4 and §5), an analyzer for the math expressions in the text ( §6), and two semantic parsing techniques to fight against the scarcity of the training data ( §7) and the complexity of the domain ( §8). Experimental results show the effectiveness of the presented techniques as well as the complexity of the task through an in-depth analysis of the end-to-end problem solving results ( §9). 2 End-to-end Math Problem Solving Fig 2 presents an overview of our end-to-end math problem solving system. A math problem text is firstly analyzed with a dependency parser. Anaphoric and coreferential expressions in the text are then identified and their antecedents are determined"</snippet5>
<abstract>We have been developing an end-to-end math problem solving system that accepts natural language input. The current paper focuses on how we analyze the problem sentences to produce logical forms. We chose a hybrid approach combining a shallow syntactic analyzer and a manually-developed lexicalized grammar. A feature of the grammar is that it is extensively typed on the basis of a formal ontology for pre-university math. These types are helpful in semantic disambiguation inside and across sentences. Experimental results show that the hybrid system produces a well-formed logical form with 88% precision and 56% recall.</abstract>
<title>Semantic Parsing of Pre-university Math Problems</title>
<introduction>Frege and Russell, the initiators of the mathematical logic, delved also into the exploration of a theory of natural language semantics (Frege, 1892;Russell, 1905). Since then, symbolic logic has been a fundamental tool and a source of inspiration in the study of language meaning. It suggests that the formalization of the two realms, mathematical reasoning and language meaning, is actually the two sides of the same coin -probably, we could not even conceive the idea of formalizing language meaning without grounding it onto mathematical reasoning. This point was first clarified by Tarski (1936;1944) mainly on formal languages and then extended to natural languages by Davidson (1967). Montague (1970a;1970b;1973) further embodied it by putting forward a terrifyingly arrogant and attractive idea of seeing a natural language as a formal language.The automation of end-to-end math problem solving thus has an outstanding status in the reDefine the two straight lines L1 and L2 on the xy-plane as L1: y = 0 (x-axis) and L2: y = √ 3x. Let P be a point on the xy-plane. Let Q be the point symmetric to P about the straight line L1, and let R be the point symmetric to P about the straight line L2. Answer the following questions:(1) Let (a, b) be the coordinates of P , then represent the coordinates of R using a and b. (2) Assuming that the distance between the two points Q and R is 2, find the locus C of P . (3) When the point P moves on C, find the maximum area of the triangle P QR and the coordinates of P that gives the maximum area.(Hokkaido Univ., 1999-Sci-3) Figure 1: Example problem search themes in natural language processing. The conceptual basis has been laid down, which connects text to the truth (= answer) through reasoning. However, we have not seen a fully automated system that instantiates it end-to-end. We wish to add a piece to the big picture by materializing it. Past studies have mainly targeted at primary school level arithmetic word problems (Bobrow, 1964;Charniak, 1969;Hos- seini et al., 2014;Shi et al., 2015;Roy and Roth, 2015;Zhou et al., 2015;Koncel-Kedziorski et al., 2015;Mitra and Baral, 2016;Upadhyay et al., 2016). In their nature, arithmetic questions are quantifier-free. Moreover they tend to include only ∧ (and) as the logical connective. The main challenge in these works was to extract simple numerical relations (most typically equations) from a real-world scenario described in a text. Seo et al. (2015) took SAT geometry questions as their benchmark. However, the nature of SAT geometry questions restricts the resulting formula's complexity. In §3, we will show that none of them includes ∀ (for all), ∨ (or) or → (implies  We take pre-university math problems falling in the theory of real-closed fields (RCF) as our benchmark because of their variety and complexity. The subject areas include real and linear algebra, complex numbers, calculus, and geometry. Furthermore, many problems involve more than one subject: e.g., algebraic curves and calculus as in Fig. 1. Their logical forms include all the logical connectives, quantifiers, and λ-abstraction. Our goal is to recognize the complex logical structures precisely, including the scopes of the quantifiers and other logical operators.In the rest of the paper, we first present an overview of an end-to-end problem solving system ( §2) and analyze the complexity of the preuniversity math benchmark in comparison with others ( §3). Among the modules in the end-to-end system, we focus on the sentence-level semantic parsing component and describe an extensivelytyped grammar ( §4 and §5), an analyzer for the math expressions in the text ( §6), and two semantic parsing techniques to fight against the scarcity of the training data ( §7) and the complexity of the domain ( §8). Experimental results show the effectiveness of the presented techniques as well as the complexity of the task through an in-depth analysis of the end-to-end problem solving results ( §9).2 End-to-end Math Problem Solving Fig. 2 presents an overview of our end-to-end math problem solving system. A math problem text is firstly analyzed with a dependency parser. Anaphoric and coreferential expressions in the text are then identified and their antecedents are determined. We assume the math formulas in the problems are encoded in MathML presentation mark-up. A specialized parser processes each one of them to determine its syntactic category and semantic content. The semantic representation of each sentence is determined by a semantic parser based on Combinatory Categorial Grammar (CCG) (Steedman, 2001(Steedman, , 2012  Table 1: Performance of the reasoning module on manually formalized pre-university problemsAfter the sentence-level processing steps, we determine the logical relations among the sentence-level logical forms (discourse parsing) by a simple rule-based system. It produces a tree structure whose leaves are labeled with sentences and internal nodes with logical connectives. Free variables in the logical form are then bound by some quantifiers (or kept free) and their scopes are determined according to the logical structure of the problem. A semantic representation of a problem is obtained as a formula in a higher-order logic through these language analysis steps.The logical representation is then rewritten using a set of axioms that define the meanings of the predicate and function symbols in the formula, such as maximum defined as follows:as well as several logical rules such as β-reduction. We hope to obtain a representation of the initial problem expressed in a decidable math theory such as RCF through these equivalencepreserving rewriting. Once we find such a formula, we invoke a computer algebra system (CAS) or an automatic theorem prover (ATP) to derive the answer.The reasoning module (i.e., the formula rewriting and the deduction with CAS and ATP) of the system has been extensively tested on a large collection of manually formalized pre-university math problems that includes more than 1,500 problems. It solves 70% of the them in the time limit of 10 minutes per problem. Table 1 shows the rate of successfully solved problems in the manually formalized version of the benchmark problems used in the current paper.</introduction>
<file>P17-1195-Figure2-1.png</file>
<figure>4</figure>
<caption>Figure 4: Bunsetsu dependency structure (top) and CCG derivation tree (bottom)</caption>
<mention10>"..."</mention10>
<mention20>"..."</mention20>
<mention50>"..."</mention50>
<lines3> A bunsetsu consists of one or more content words followed by zero or more function words. The dependencies among bunsetsus mostly correspond to the predicate-argument and interclausal dependencies (Fig 4). The dependency structure hence matches the overall structure of a CCG tree only leaving the details unspecified"</lines3>
<lines5> The syntactic structure of Japanese sentences has traditionally been analyzed based on the relations among word chunks called bunsetsus. A bunsetsu consists of one or more content words followed by zero or more function words. The dependencies among bunsetsus mostly correspond to the predicate-argument and interclausal dependencies (Fig 4). The dependency structure hence matches the overall structure of a CCG tree only leaving the details unspecified. We derive a full CCG-tree by using a bunsetsu dependency tree as a constraint"</lines5>
<snippet3> A bunsetsu consists of one or more content words followed by zero or more function words. The dependencies among bunsetsus mostly correspond to the predicate-argument and interclausal dependencies (Fig 4). The dependency structure hence matches the overall structure of a CCG tree only leaving the details unspecified"</snippet3>
<snippet5> The syntactic structure of Japanese sentences has traditionally been analyzed based on the relations among word chunks called bunsetsus. A bunsetsu consists of one or more content words followed by zero or more function words. The dependencies among bunsetsus mostly correspond to the predicate-argument and interclausal dependencies (Fig 4). The dependency structure hence matches the overall structure of a CCG tree only leaving the details unspecified. We derive a full CCG-tree by using a bunsetsu dependency tree as a constraint"</snippet5>
<abstract>We have been developing an end-to-end math problem solving system that accepts natural language input. The current paper focuses on how we analyze the problem sentences to produce logical forms. We chose a hybrid approach combining a shallow syntactic analyzer and a manually-developed lexicalized grammar. A feature of the grammar is that it is extensively typed on the basis of a formal ontology for pre-university math. These types are helpful in semantic disambiguation inside and across sentences. Experimental results show that the hybrid system produces a well-formed logical form with 88% precision and 56% recall.</abstract>
<title>Semantic Parsing of Pre-university Math Problems</title>
<introduction>Frege and Russell, the initiators of the mathematical logic, delved also into the exploration of a theory of natural language semantics (Frege, 1892;Russell, 1905). Since then, symbolic logic has been a fundamental tool and a source of inspiration in the study of language meaning. It suggests that the formalization of the two realms, mathematical reasoning and language meaning, is actually the two sides of the same coin -probably, we could not even conceive the idea of formalizing language meaning without grounding it onto mathematical reasoning. This point was first clarified by Tarski (1936;1944) mainly on formal languages and then extended to natural languages by Davidson (1967). Montague (1970a;1970b;1973) further embodied it by putting forward a terrifyingly arrogant and attractive idea of seeing a natural language as a formal language.The automation of end-to-end math problem solving thus has an outstanding status in the reDefine the two straight lines L1 and L2 on the xy-plane as L1: y = 0 (x-axis) and L2: y = √ 3x. Let P be a point on the xy-plane. Let Q be the point symmetric to P about the straight line L1, and let R be the point symmetric to P about the straight line L2. Answer the following questions:(1) Let (a, b) be the coordinates of P , then represent the coordinates of R using a and b. (2) Assuming that the distance between the two points Q and R is 2, find the locus C of P . (3) When the point P moves on C, find the maximum area of the triangle P QR and the coordinates of P that gives the maximum area.(Hokkaido Univ., 1999-Sci-3) Figure 1: Example problem search themes in natural language processing. The conceptual basis has been laid down, which connects text to the truth (= answer) through reasoning. However, we have not seen a fully automated system that instantiates it end-to-end. We wish to add a piece to the big picture by materializing it. Past studies have mainly targeted at primary school level arithmetic word problems (Bobrow, 1964;Charniak, 1969;Hos- seini et al., 2014;Shi et al., 2015;Roy and Roth, 2015;Zhou et al., 2015;Koncel-Kedziorski et al., 2015;Mitra and Baral, 2016;Upadhyay et al., 2016). In their nature, arithmetic questions are quantifier-free. Moreover they tend to include only ∧ (and) as the logical connective. The main challenge in these works was to extract simple numerical relations (most typically equations) from a real-world scenario described in a text. Seo et al. (2015) took SAT geometry questions as their benchmark. However, the nature of SAT geometry questions restricts the resulting formula's complexity. In §3, we will show that none of them includes ∀ (for all), ∨ (or) or → (implies  We take pre-university math problems falling in the theory of real-closed fields (RCF) as our benchmark because of their variety and complexity. The subject areas include real and linear algebra, complex numbers, calculus, and geometry. Furthermore, many problems involve more than one subject: e.g., algebraic curves and calculus as in Fig. 1. Their logical forms include all the logical connectives, quantifiers, and λ-abstraction. Our goal is to recognize the complex logical structures precisely, including the scopes of the quantifiers and other logical operators.In the rest of the paper, we first present an overview of an end-to-end problem solving system ( §2) and analyze the complexity of the preuniversity math benchmark in comparison with others ( §3). Among the modules in the end-to-end system, we focus on the sentence-level semantic parsing component and describe an extensivelytyped grammar ( §4 and §5), an analyzer for the math expressions in the text ( §6), and two semantic parsing techniques to fight against the scarcity of the training data ( §7) and the complexity of the domain ( §8). Experimental results show the effectiveness of the presented techniques as well as the complexity of the task through an in-depth analysis of the end-to-end problem solving results ( §9).2 End-to-end Math Problem Solving Fig. 2 presents an overview of our end-to-end math problem solving system. A math problem text is firstly analyzed with a dependency parser. Anaphoric and coreferential expressions in the text are then identified and their antecedents are determined. We assume the math formulas in the problems are encoded in MathML presentation mark-up. A specialized parser processes each one of them to determine its syntactic category and semantic content. The semantic representation of each sentence is determined by a semantic parser based on Combinatory Categorial Grammar (CCG) (Steedman, 2001(Steedman, , 2012  Table 1: Performance of the reasoning module on manually formalized pre-university problemsAfter the sentence-level processing steps, we determine the logical relations among the sentence-level logical forms (discourse parsing) by a simple rule-based system. It produces a tree structure whose leaves are labeled with sentences and internal nodes with logical connectives. Free variables in the logical form are then bound by some quantifiers (or kept free) and their scopes are determined according to the logical structure of the problem. A semantic representation of a problem is obtained as a formula in a higher-order logic through these language analysis steps.The logical representation is then rewritten using a set of axioms that define the meanings of the predicate and function symbols in the formula, such as maximum defined as follows:as well as several logical rules such as β-reduction. We hope to obtain a representation of the initial problem expressed in a decidable math theory such as RCF through these equivalencepreserving rewriting. Once we find such a formula, we invoke a computer algebra system (CAS) or an automatic theorem prover (ATP) to derive the answer.The reasoning module (i.e., the formula rewriting and the deduction with CAS and ATP) of the system has been extensively tested on a large collection of manually formalized pre-university math problems that includes more than 1,500 problems. It solves 70% of the them in the time limit of 10 minutes per problem. Table 1 shows the rate of successfully solved problems in the manually formalized version of the benchmark problems used in the current paper.</introduction>
<file>P17-1195-Figure4-1.png</file>
<figure>6</figure>
<caption>Figure 6: CCG parsing with type environment</caption>
<mention10>"..."</mention10>
<mention20>"..."</mention20>
<mention50>"..."</mention50>
<lines3> The type constraints implied in a discourse are accumulated in the environment and block the generation of incoherent derivations (Algorithm 1). Fig 6 presents an example of a parsing result, in which the type constraints implied in the two clauses are unified at the root and the type of U is determined. When we apply a combinatory rule, we first check if the environments of the child chart items are unifiable"</lines3>
<lines5> We associate a type environment with each chart item and refine it through parsing. The type constraints implied in a discourse are accumulated in the environment and block the generation of incoherent derivations (Algorithm 1). Fig 6 presents an example of a parsing result, in which the type constraints implied in the two clauses are unified at the root and the type of U is determined. When we apply a combinatory rule, we first check if the environments of the child chart items are unifiable. 1f so, we put the unified environment in the parent item and apply the unifier to the type features in the parent category"</lines5>
<snippet3> The type constraints implied in a discourse are accumulated in the environment and block the generation of incoherent derivations (Algorithm 1). Fig 6 presents an example of a parsing result, in which the type constraints implied in the two clauses are unified at the root and the type of U is determined. When we apply a combinatory rule, we first check if the environments of the child chart items are unifiable"</snippet3>
<snippet5> We associate a type environment with each chart item and refine it through parsing. The type constraints implied in a discourse are accumulated in the environment and block the generation of incoherent derivations (Algorithm 1). Fig 6 presents an example of a parsing result, in which the type constraints implied in the two clauses are unified at the root and the type of U is determined. When we apply a combinatory rule, we first check if the environments of the child chart items are unifiable. 1f so, we put the unified environment in the parent item and apply the unifier to the type features in the parent category"</snippet5>
<abstract>We have been developing an end-to-end math problem solving system that accepts natural language input. The current paper focuses on how we analyze the problem sentences to produce logical forms. We chose a hybrid approach combining a shallow syntactic analyzer and a manually-developed lexicalized grammar. A feature of the grammar is that it is extensively typed on the basis of a formal ontology for pre-university math. These types are helpful in semantic disambiguation inside and across sentences. Experimental results show that the hybrid system produces a well-formed logical form with 88% precision and 56% recall.</abstract>
<title>Semantic Parsing of Pre-university Math Problems</title>
<introduction>Frege and Russell, the initiators of the mathematical logic, delved also into the exploration of a theory of natural language semantics (Frege, 1892;Russell, 1905). Since then, symbolic logic has been a fundamental tool and a source of inspiration in the study of language meaning. It suggests that the formalization of the two realms, mathematical reasoning and language meaning, is actually the two sides of the same coin -probably, we could not even conceive the idea of formalizing language meaning without grounding it onto mathematical reasoning. This point was first clarified by Tarski (1936;1944) mainly on formal languages and then extended to natural languages by Davidson (1967). Montague (1970a;1970b;1973) further embodied it by putting forward a terrifyingly arrogant and attractive idea of seeing a natural language as a formal language.The automation of end-to-end math problem solving thus has an outstanding status in the reDefine the two straight lines L1 and L2 on the xy-plane as L1: y = 0 (x-axis) and L2: y = √ 3x. Let P be a point on the xy-plane. Let Q be the point symmetric to P about the straight line L1, and let R be the point symmetric to P about the straight line L2. Answer the following questions:(1) Let (a, b) be the coordinates of P , then represent the coordinates of R using a and b. (2) Assuming that the distance between the two points Q and R is 2, find the locus C of P . (3) When the point P moves on C, find the maximum area of the triangle P QR and the coordinates of P that gives the maximum area.(Hokkaido Univ., 1999-Sci-3) Figure 1: Example problem search themes in natural language processing. The conceptual basis has been laid down, which connects text to the truth (= answer) through reasoning. However, we have not seen a fully automated system that instantiates it end-to-end. We wish to add a piece to the big picture by materializing it. Past studies have mainly targeted at primary school level arithmetic word problems (Bobrow, 1964;Charniak, 1969;Hos- seini et al., 2014;Shi et al., 2015;Roy and Roth, 2015;Zhou et al., 2015;Koncel-Kedziorski et al., 2015;Mitra and Baral, 2016;Upadhyay et al., 2016). In their nature, arithmetic questions are quantifier-free. Moreover they tend to include only ∧ (and) as the logical connective. The main challenge in these works was to extract simple numerical relations (most typically equations) from a real-world scenario described in a text. Seo et al. (2015) took SAT geometry questions as their benchmark. However, the nature of SAT geometry questions restricts the resulting formula's complexity. In §3, we will show that none of them includes ∀ (for all), ∨ (or) or → (implies  We take pre-university math problems falling in the theory of real-closed fields (RCF) as our benchmark because of their variety and complexity. The subject areas include real and linear algebra, complex numbers, calculus, and geometry. Furthermore, many problems involve more than one subject: e.g., algebraic curves and calculus as in Fig. 1. Their logical forms include all the logical connectives, quantifiers, and λ-abstraction. Our goal is to recognize the complex logical structures precisely, including the scopes of the quantifiers and other logical operators.In the rest of the paper, we first present an overview of an end-to-end problem solving system ( §2) and analyze the complexity of the preuniversity math benchmark in comparison with others ( §3). Among the modules in the end-to-end system, we focus on the sentence-level semantic parsing component and describe an extensivelytyped grammar ( §4 and §5), an analyzer for the math expressions in the text ( §6), and two semantic parsing techniques to fight against the scarcity of the training data ( §7) and the complexity of the domain ( §8). Experimental results show the effectiveness of the presented techniques as well as the complexity of the task through an in-depth analysis of the end-to-end problem solving results ( §9).2 End-to-end Math Problem Solving Fig. 2 presents an overview of our end-to-end math problem solving system. A math problem text is firstly analyzed with a dependency parser. Anaphoric and coreferential expressions in the text are then identified and their antecedents are determined. We assume the math formulas in the problems are encoded in MathML presentation mark-up. A specialized parser processes each one of them to determine its syntactic category and semantic content. The semantic representation of each sentence is determined by a semantic parser based on Combinatory Categorial Grammar (CCG) (Steedman, 2001(Steedman, , 2012  Table 1: Performance of the reasoning module on manually formalized pre-university problemsAfter the sentence-level processing steps, we determine the logical relations among the sentence-level logical forms (discourse parsing) by a simple rule-based system. It produces a tree structure whose leaves are labeled with sentences and internal nodes with logical connectives. Free variables in the logical form are then bound by some quantifiers (or kept free) and their scopes are determined according to the logical structure of the problem. A semantic representation of a problem is obtained as a formula in a higher-order logic through these language analysis steps.The logical representation is then rewritten using a set of axioms that define the meanings of the predicate and function symbols in the formula, such as maximum defined as follows:as well as several logical rules such as β-reduction. We hope to obtain a representation of the initial problem expressed in a decidable math theory such as RCF through these equivalencepreserving rewriting. Once we find such a formula, we invoke a computer algebra system (CAS) or an automatic theorem prover (ATP) to derive the answer.The reasoning module (i.e., the formula rewriting and the deduction with CAS and ATP) of the system has been extensively tested on a large collection of manually formalized pre-university math problems that includes more than 1,500 problems. It solves 70% of the them in the time limit of 10 minutes per problem. Table 1 shows the rate of successfully solved problems in the manually formalized version of the benchmark problems used in the current paper.</introduction>
<file>P17-1195-Figure6-1.png</file>